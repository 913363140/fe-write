## 闭包

#### 什么是闭包
**MDN**: 闭包是一个能够访问自由变量的函数 （理论上的闭包）
**自由变量**：是只一个函数使用的既不是参数，也不是函数局部作用域内的变量的变量

闭包是一个函数对外部函数变量的引用。

函数执行后返回的结果是一个内部函数，并被外部变量引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

#### 闭包原理
函数执行分为两个阶段：预编译阶段和执行阶段
- 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个’闭包‘对象并保存对应变量值，如果已存在”闭包“，则只需要添加对应的属性就可以
- 执行完后，函数执行上下文会被销毁，函数对’闭包‘对象的引用也会销毁，但其内部函数还保持对该闭包的引用，所以内部函数可以继续使用‘外部函数’中的变量

利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到他的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，知道内部函数被销毁后才会销毁

#### 优点
1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，供后续使用
2. 避免变量污染全局
3. 把变量存到独立作用域，作为私有变量

#### 缺点
1. 变量常驻内存，可能会导致内存泄露
2. 可能对处理速度有影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链的长度
3. 可能获取到意外的值（captured value）

#### 应用场景
**应用场景一**：典型应用是在模块封装，在各个模块规范出现之前，都是用这样的方式防止变量污染
**应用场景二**：在循环中创建闭包，防止取到意外的值
```
  var data = []
  for (var i = 0; i < 3; i++) {
    data[i] = function() {
      console.log(i)
    }
  }
  
  data[0]() // 3
  data[1]() // 3
  data[2]() // 3
```

- 使用IIFE创建闭包
```
  var data = []
  for (var i = 0; i < 3; i++) {
    data[i] = (function() {
      console.log(i)
    })(i)
  }

  data[0]() // 0
  data[1]() // 1
  data[2]() // 2
```